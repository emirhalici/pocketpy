[[{"l":"Welcome to pocketpy","p":["pkpy is a lightweight(~ 10000 LOC) Python interpreter for game scripting, built on C++ 17 with STL.","It aims to be an alternative to lua for game scripting, with elegant syntax, powerful features and competitive performance. pkpy is extremely easy to embed via a single header file pocketpy.h, without external dependencies."]},{"l":"What it looks like"},{"l":"Sponsor me","p":["You can sponsor me via Github Sponsors."]}],[{"l":"Installation","p":["Download the pocketpy.h on our GitHub Release page. And #include it in your project."]},{"l":"Compile flags","p":["To compile it with your project, these flags must be set:","--std=c++17 flag must be set","Exception must be enabled","RTTI is not required"]},{"l":"Example"},{"l":"Overview","p":["pkpy's C++ interfaces are organized in an object-oriented way. All classes are located in pkpy namespace.","The most important class is the VM class. A VM instance is a python virtual machine which holds all necessary runtime states, including callstack, modules, variables, etc.","A process can have multiple VM instances. Each VM instance is independent from each other.","You need to use the C++ new operator to create a VM instance. Do not declare it on the stack.","The constructor can take 1 extra parameters."]},{"i":"vmbool-enable_ostrue","l":"VM(bool enable_os=true)","p":["enable_os, whether to enable OS-related features or not. This setting controls the availability of priviledged modules such os io and os as well as builtin function open.","When you are done with the VM instance, use delete operator to dispose it."]},{"l":"Hook standard buffer","p":["By default, pkpy outputs all messages and errors to stdout and stderr. You can redirect them to your own buffer by setting vm-_stdout and vm-_stderr.","These two fields are C function pointers PrintFunc with the following signature:"]}],[{"l":"Execute Python code"},{"l":"Simple execution","p":["Once you have a VM instance, you can execute python code by calling exec method."]},{"i":"pyobject-execstr-source-str-filename-compilemode-mode-pyobject-_modulenullptr","l":"PyObject* exec(Str source, Str filename, CompileMode mode, PyObject* _module=nullptr)","p":["source, the python source code to be executed","filename, the filename of the source code. This is used for error reporting","mode, the compile mode. See below for details","module, the module where the code will be executed. If nullptr, the code will be executed in the __main__ module","exec handles possible exceptions and returns a PyObject*. If the execution is not successful, e.g. a syntax error or a runtime exception, the return value will be nullptr."]},{"l":"Compile mode","p":["The mode parameter controls how the source code is compiled. There are 4 possible values:","EXEC_MODE, this is the default mode. Just do normal execution.","EVAL_MODE, this mode is used for evaluating a single expression. The source should be a single expression. It cannot contain any statements.","REPL_MODE, this mode is used for REPL. It is similar to EXEC_MODE, but generates PRINT_EXPR opcode when necessary.","CELL_MODE, this mode is designed for Jupyter like execution.","JSON_MODE, this mode is used for JSON parsing. It is similar to EVAL_MODE, but uses a lexing rule designed for JSON."]},{"l":"Fine-grained execution","p":["In some cases, you may want to execute python code in a more fine-grained way. These two methods are provided for this purpose:","CodeObject_ compile(Str source, Str filename, CompileMode mode, bool unknown_global_scope)","PyObject* _exec(CodeObject_ co, PyObject* _module)","compile compiles the source code into a CodeObject_ instance._exec executes the CodeObject_ instance. Leave unknown_global_scope to false if you are not sure.","It does not handle exceptions, you need to use try..catch manually."]}],[{"l":"Interop with PyObject","p":["In pkpy, any python object is represented by a PyObject*."]},{"i":"create-pyobject-from-c-type","l":"Create PyObject* from C type","p":["A set of overloaded function PyObject* py_var(VM* vm, ...) were implemented to create a PyObject* from a supported C type. In order to make it less verbose, we usually use macro VAR(...), which is just a wrapper of py_var.","For example, create a python int object from a C i64 type:","Each python type has a corresponding C type, for example, int in python is i64 in C. python's list corresponds to List, str corresponds to Str, etc. For strings, we have defined a set of overloaded version including const char*, std::string, std::string_view, Str, etc.","A more complex example is to create a python list. In the following code, we create a list equals to [0, 1, 2, 3].","Please note that std::move is used here to avoid unnecessary copy. Most types have both a rvalue and a lvalue version of VAR function."]},{"i":"access-internal-c-type-of-pyobject","l":"Access internal C type of PyObject*","p":["A set of template function T py_castT(VM* vm, PyObject* obj) were implemented for each supported C type. We usually use macro CAST(T, ...) to make it less verbose.","The CAST function will check the type of obj before casting. If the type is not matched, a TypeError will be thrown.","However, this type check has a cost. If you are sure about the type of obj, you can use the underscore version _CAST to skip the type check.","For complex objects like list, we can use reference cast to avoid unnecessary copy."]},{"i":"check-type-of-pyobject","l":"Check type of PyObject*","p":["Each PyObject* has a Type field to indicate its type. Type is just an integer which is the global index in vm-_all_types.","VM class has a set of predefined Type constants for quick access. They are prefixed by tp_. For example, tp_object(object), tp_int(int), tp_str(str), tp_list(list), etc.","Types are divided into tagged type and non-tagged type.","int and float are tagged type.","Other types are non-tagged type.","To determine whether a PyObject* is of a specific type, you can use the following functions:","bool is_type(PyObject* obj, Type type)","bool is_int(PyObject* obj)","bool is_float(PyObject* obj)","bool is_tagged(PyObject* obj)","bool is_non_tagged_type(PyObject* obj, Type type)","Simply put, is_type is the most general function and can check any types. Other variants are designed for specific types and are faster.","You can also use check_ prefix functions assert the type of a PyObject*, which will throw TypeError on failure.","void check_type(PyObject* obj, Type type)","void check_non_tagged_type(PyObject* obj, Type type)"]}],[{"l":"Access attributes"},{"l":"Direct access","p":["Some python objects have an instance dict, a.k.a, __dict__ in cpython. You can use obj-attr() to manipulate the instance dict of an object.","However, you cannot call attr on an object which does not have an instance dict. For example, the int object.","To determine whether an object has instance dict or not, you can use this snippet."]},{"l":"General access","p":["As you can see, direct access does not take care of derived attributes or methods. In most cases, what you need is getattr and setattr. These two methods handle all possible cases."]},{"i":"pyobject-getattrpyobject-obj-strname-name-bool-throw_errtrue","l":"PyObject* getattr(PyObject* obj, StrName name, bool throw_err=true)","p":["This method is equivalent to getattr in python. If the attribute is not found, it will return nullptr or throw an AttributeError depending on the value of throw_err."]},{"i":"void-setattrpyobject-strname-pyobject","l":"void setattr(PyObject*, StrName, PyObject*)","p":["This method is equivalent to setattr in python. It raises TypeError if the object does not support attribute assignment."]}],[{"l":"Call Python function","p":["pkpy uses a variant of the Vectorcall protocol (PEP 590).","You can use call to invoke any python callable object, including functions, methods, classes, etc. For methods, call_method can be used.","PyObject* call(PyObject* obj, ...)","PyObject* call_method(PyObject* obj, StrName name, ...)"]},{"l":"Exmaple","p":["Let's create a dict object and set a key-value pair, which equals to the following python snippet.","First, create an empty dict object,","And set a key-value pair,","And get the value,"]}],[{"l":"Bind native function","p":["pkpy allows to wrap a function pointer as a python function or method that can be called in python code. This function pointer has the following signature:","The first argument is the pointer of VM instance.","The second argument is an array-like object indicates the arguments list. You can use [] operator to get the element.","The return value is a PyObject*, which should not be nullptr. If there is no return value, return vm-None.","Native functions do not support keyword arguments."]},{"l":"Bind a function","p":["Assume you have a cpp function bool equals(int a, int b).","You can bind it into test.equals by using vm-bind_funcARGC:","The first argument is the target object to bind. It can be any python object with an instance dict, such as a module, a class, or an instance.","The second argument is the function name.","The third argument is the function pointer. We often use lambda expression to wrap it. A non-capturing lambda expression can be converted to a function pointer.","The template argument ARGC is the argument count of the function. If the function is variadic, use -1 as the argument count.","The interpreter will ensure args.size() == ARGC and throws TypeError if not. For variadic functions, you need to check args.size() manually.","If you want to bind a function into builtins module, use vm-bind_builtin_funcARGC instead."]},{"l":"Bind a constructor","p":["The constructor of a class is a special function that returns an instance of the class. It corresponds to the __new__ magic method in python (not __init__)."]},{"l":"Bind a method","p":["The vm-bind_methodARGC usage is almost the same as vm-bind_funcARGC. The only difference is that ARGC in vm-bind_methodARGC does not include the self argument."]},{"l":"Bind a magic method","p":["For some magic methods, we provide specialized binding function. They do not take universal function pointer as argument. You need to provide the detailed Type object and the corresponding function pointer.","This specialized binding function has optimizations and result in better performance when calling from python code.","For example, vm-bind__add__ is preferred over vm-bind_method1(type, __add__, ...)."]},{"l":"Bind a property","p":["a property is a python's property that attached to a type instance with a getter and an optional setter. It is a data descriptor. A property redirects attribute access to specific functions.","You can use @property to create python property or use vm-property to create native property."]}],[{"l":"Create modules","p":["Modules are stored in vm-_modules and vm-_lazy_modules. They are both dict-like objects."]},{"l":"Lazy modules","p":["A lazy module is a python source file. It is compiled and executed when it is imported. Use [] operator to add a lazy module."]},{"l":"Native modules","p":["A native module is a module written in c++ or mixed c++/python. Native modules are always compiled and executed when the VM is created.","To creata a native module, use vm-new_module(...)."]},{"l":"Module resolution order","p":["When you do import a module, the VM will try to find it in the following order:","Search vm-_modules, if found, return it.","Search vm-_lazy_modules, if found, compile and execute it, then return it.","Try vm-_import_handler."]},{"l":"Customized import handler","p":["You can use vm-_import_handler to provide a custom import handler for the 3rd step. if both enable_os and PK_ENABLE_OS are true, the default import_handler is as follows:"]},{"l":"Import module via cpp","p":["You can use vm-py_import to import a module. This is equivalent to import in python. Return the module object if success."]}],[{"l":"Wrap native struct","p":["Add PY_CLASS macro into your struct and implement a static function _register."]},{"l":"Example"},{"l":"Usage"}],[{"l":"Complete example","p":["In this example, we will create a linalg module and implement a vec2 type with some methods. And make them available in python just like this."]},{"l":"Implement Vec2 struct in cpp"},{"l":"Create PyVec2 wrapper"},{"l":"Create linalg module"},{"l":"Further reading","p":["See linalg.h for the complete implementation."]}],[{"l":"Advanced config","p":["You can create a user_config.h in the same directory as pocketpy.h to override some default settings.","Copy src/config.h and rename it to user_config.h.","Define a macro PK_USER_CONFIG_H in user_config.h. This invalidates the default config.h and enables your user_config.h.","Edit user_config.h to override default settings."]}],[{"l":"Basic Features","p":["(1, 2, 'a')","[1, 2, 'a']","[i for i in range(5)]","{'a': 1, 'b': 2}","@cache","a, *b = [1, 2, 3]","a, b = 1, 2","a[1:2], a[:2], a[1:]","class A(B):","Context Block","Decorator","def f(a:int, b:float=1)","def f(x,*args,y=1):","Dict","Dynamic Code","eval()/exec()","Example","Exception","F-String","f'value is {x}'","for/while/break/continue","Function","Generator","hasattr()/getattr()/setattr()","If Else","if..else..elif","Import","import/from..import","List","ListComp","Loop","Name","raise/try..catch","Reflection","Slice","Star Unpacking","Subclass","Supported","The following table shows the basic features of pkpy with respect to cpython. The features marked with YES are supported, and the features marked with NO are not supported.","Tuple","Type Annotation","Unpacking","with expr as id:","YES","yield i"]}],[{"l":"Comparison with CPython","p":["cpython is the reference implementation of the Python programming language. It is written in C and is the most widely used implementation of Python."]},{"l":"The design goal","p":["pkpy aims to be an alternative to lua for game scripting, not cpython for general purpose programming.","For syntax and semantics, pkpy is designed to be as close to cpython as possible.","For ecosystem and others, pkpy is not compatible with cpython.","pkpy supports most of the syntax and semantics of python. For performance and simplicity, some features are not implemented, or behave differently. The easiest way to test a feature is to try it on your browser."]},{"l":"Unimplemented features","p":["__getattr__ and __setattr__.","Descriptor protocol __get__ and __set__. However, @property is implemented.","__slots__ in class definition.","Unpacking in list and dict literals, e.g. [1, 2, *a].","Access the exception object in try..except.","else clause in try..except.","Inplace methods like __iadd__ and __imul__.","__del__ in class definition.","Multiple inheritance."]},{"l":"Different behaviors","p":["positional and keyword arguments are strictly evaluated.","When a generator is exhausted, StopIteration is returned instead of raised.","++i and --j is an increment/decrement statement, not an expression.","int does not derive from bool.","int is not of unlimited precision. In 32 bit system, int and float is 30 bit; in 64 bit system, they are both 62 bit.","__ne__ is not required. Define __eq__ is enough.","Raw string cannot have boundary quotes in it, even escaped. See #55.","In a starred unpacked assignment, e.g. a, b, *c = x, the starred variable can only be presented in the last position. a, *b, c = x is not supported.","A Tab is equivalent to 4 spaces. You can mix Tab and spaces in indentation, but it is not recommended.","%, , //, ^ and | for int behave the same as C, not python.","int is of limited precision. For arbitrary sized integers, you may use long type explicitly."]}],[{"l":"Arbitrary Sized Integers","p":["Unlike cpython, pkpy's int is of limited precision. In 32 bit platforms, it is 30 bit; in 64 bit platforms, it is 62 bit.","For arbitrary sized integers, we provide a builtin long type, just like python2's long. long is implemented via pure python in _long.py."]},{"l":"Create a long object","p":["You can use L suffix to create a long literal from a decimal literal. Also, you can use long() function to create a long object from a int object or a str object.","This feature is still under development. Some operations are missing, and some operations are not optimized."]}],[{"l":"Goto Statement","p":["pkpy supports goto and label just like C. You are allowed to change the control flow unconditionally."]},{"l":"Syntax"},{"l":"Example"}],[{"l":"Increment Statement","p":["pkpy provides ++i and --j statements to operate a simple named int variable.","++i is equivalent to i+=1, but much faster","--j is equivalent to j-=1, but much faster"]},{"l":"Example"}],[{"l":"Undefined Behaviour","p":["These are the undefined behaviours of pkpy. The behaviour of pkpy is undefined if you do the following things.","Delete a builtin object. For example, del int.__add__.","Call an unbound method with the wrong type of self. For example, int.__add__('1', 2).","Use goto statement to jump out of a context block.","Type T's __new__ returns an object that is not an instance of T.","Call __new__ with a type that is not a subclass of type.","__eq__, __lt__ or __contains__, etc.. returns a value that is not a boolean.","Division by zero."]}],[{"l":"base64"},{"i":"base64b64encodeb-bytes---bytes","l":"base64.b64encode(b: bytes) - bytes","p":["Encode bytes-like object b using the standard Base64 alphabet."]},{"i":"base64b64decodeb-bytes---bytes","l":"base64.b64decode(b: bytes) - bytes","p":["Decode Base64 encoded bytes-like object b."]}],[{"l":"bisect"},{"i":"bisectbisect_lefta-x","l":"bisect.bisect_left(a, x)","p":["Return the index where to insert item x in list a, assuming a is sorted."]},{"i":"bisectbisect_righta-x","l":"bisect.bisect_right(a, x)","p":["Return the index where to insert item x in list a, assuming a is sorted."]},{"i":"bisectinsort_lefta-x","l":"bisect.insort_left(a, x)","p":["Insert item x in list a, and keep it sorted assuming a is sorted.","If x is already in a, insert it to the left of the leftmost x."]},{"i":"bisectinsort_righta-x","l":"bisect.insort_right(a, x)","p":["Insert item x in list a, and keep it sorted assuming a is sorted.","If x is already in a, insert it to the right of the rightmost x."]}],[{"l":"c","p":["Interop with pointers and C structs."]}],[{"l":"collections"},{"i":"collectionscounteriterable","l":"collections.Counter(iterable)","p":["Return a dict containing the counts of each element in iterable."]},{"i":"collectionsdeque","l":"collections.deque","p":["A double-ended queue."]},{"i":"collectionsdefaultdict","l":"collections.defaultdict","p":["A dict wrapper that calls a factory function to supply missing values. It is not a subclass of dict."]}],[{"l":"datetime","p":["This module is not available now."]}],[{"l":"easing","p":["EaseInBack(x: float) - float","EaseInBounce(x: float) - float","EaseInCirc(x: float) - float","EaseInCubic(x: float) - float","EaseInElastic(x: float) - float","EaseInExpo(x: float) - float","EaseInOutBack(x: float) - float","EaseInOutBounce(x: float) - float","EaseInOutCirc(x: float) - float","EaseInOutCubic(x: float) - float","EaseInOutElastic(x: float) - float","EaseInOutExpo(x: float) - float","EaseInOutQuad(x: float) - float","EaseInOutQuart(x: float) - float","EaseInOutQuint(x: float) - float","EaseInOutSine(x: float) - float","EaseInQuad(x: float) - float","EaseInQuart(x: float) - float","EaseInQuint(x: float) - float","EaseInSine(x: float) - float","EaseLinear(x: float) - float","EaseOutBack(x: float) - float","EaseOutBounce(x: float) - float","EaseOutCirc(x: float) - float","EaseOutCubic(x: float) - float","EaseOutElastic(x: float) - float","EaseOutExpo(x: float) - float","EaseOutQuad(x: float) - float","EaseOutQuart(x: float) - float","EaseOutQuint(x: float) - float","EaseOutSine(x: float) - float","Python wrapper for easing functions."]}],[{"l":"gc"},{"i":"gccollect","l":"gc.collect()","p":["Invoke the garbage collector."]}],[{"l":"heapq"},{"i":"heapqheappushheap-item","l":"heapq.heappush(heap, item)","p":["Push the value item onto the heap, maintaining the heap invariant."]},{"i":"heapqheappopheap","l":"heapq.heappop(heap)","p":["Pop and return the smallest item from the heap, maintaining the heap invariant. If the heap is empty, IndexError is raised. To access the smallest item without popping it, use heap[0]."]},{"i":"heapqheapifyx","l":"heapq.heapify(x)","p":["Transform list x into a heap, in-place, in linear time."]},{"i":"heapqheappushpopheap-item","l":"heapq.heappushpop(heap, item)","p":["Push item on the heap, then pop and return the smallest item from the heap. The combined action runs more efficiently than heappush() followed by a separate heappop()."]},{"i":"heapqheapreplaceheap-item","l":"heapq.heapreplace(heap, item)","p":["Pop and return the smallest item from the heap, and also push the new item. The heap size doesnâ€™t change. If the heap is empty, IndexError is raised."]}],[{"l":"json"},{"i":"jsonloadss","l":"json.loads(s)","p":["Decode a JSON string into a python object.","It is supported by the eval() function."]},{"i":"jsondumpsobj","l":"json.dumps(obj)","p":["Encode a python object into a JSON string.","It is supported by the compiler with JSON_MODE enabled.","There is a special method __json__. If defined, it will be called when json.dumps() is called."]}],[{"l":"linalg","p":["Provide mat3x3, vec2 and vec3 types."]}],[{"l":"math"},{"i":"mathpi","l":"math.pi","p":["3.141592653589793"]},{"i":"mathe","l":"math.e","p":["2.718281828459045"]},{"i":"mathinf","l":"math.inf","p":["The inf."]},{"i":"mathnan","l":"math.nan","p":["The nan."]},{"i":"mathceilx","l":"math.ceil(x)","p":["Return the ceiling of x as a float, the smallest integer value greater than or equal to x."]},{"i":"mathfabsx","l":"math.fabs(x)","p":["Return the absolute value of x."]},{"i":"mathfloorx","l":"math.floor(x)","p":["Return the floor of x as a float, the largest integer value less than or equal to x."]},{"i":"mathfsumiterable","l":"math.fsum(iterable)","p":["Return an accurate floating point sum of values in the iterable. Avoids loss of precision by tracking multiple intermediate partial sums:"]},{"i":"mathgcda-b","l":"math.gcd(a, b)","p":["Return the greatest common divisor of the integers a and b."]},{"i":"mathisfinitex","l":"math.isfinite(x)","p":["Return True if x is neither an infinity nor a NaN, and False otherwise."]},{"i":"mathisinfx","l":"math.isinf(x)","p":["Return True if x is a positive or negative infinity, and False otherwise."]},{"i":"mathisnanx","l":"math.isnan(x)","p":["Return True if x is a NaN (not a number), and False otherwise."]},{"i":"mathexpx","l":"math.exp(x)","p":["Return e raised to the power of x."]},{"i":"mathlogx","l":"math.log(x)","p":["Return the natural logarithm of x(to base e)."]},{"i":"mathlog2x","l":"math.log2(x)","p":["Return the base-2 logarithm of x. This is usually more accurate than log(x, 2)."]},{"i":"mathlog10x","l":"math.log10(x)","p":["Return the base-10 logarithm of x. This is usually more accurate than log(x, 10)."]},{"i":"mathpowx-y","l":"math.pow(x, y)","p":["Return x raised to the power y."]},{"i":"mathsqrtx","l":"math.sqrt(x)","p":["Return the square root of x."]},{"i":"mathacosx","l":"math.acos(x)","p":["Return the arc cosine of x, in radians."]},{"i":"mathasinx","l":"math.asin(x)","p":["Return the arc sine of x, in radians."]},{"i":"mathatanx","l":"math.atan(x)","p":["Return the arc tangent of x, in radians."]},{"i":"mathatan2y-x","l":"math.atan2(y, x)","p":["Return atan(y / x), in radians. The result is between -pi and pi. The vector in the plane from the origin to point (x, y) makes this angle with the positive X axis. The point of atan2() is that the signs of both inputs are known to it, so it can compute the correct quadrant for the angle. For example, atan(1) and atan2(1, 1) are both pi/4, but atan2(-1, -1) is -3*pi/4."]},{"i":"mathcosx","l":"math.cos(x)","p":["Return the cosine of x radians."]},{"i":"mathsinx","l":"math.sin(x)","p":["Return the sine of x radians."]},{"i":"mathtanx","l":"math.tan(x)","p":["Return the tangent of x radians."]},{"i":"mathdegreesx","l":"math.degrees(x)","p":["Convert angle x from radians to degrees."]},{"i":"mathradiansx","l":"math.radians(x)","p":["Convert angle x from degrees to radians."]},{"i":"mathmodfx","l":"math.modf(x)","p":["Return the fractional and integer parts of x. Both results carry the sign of x and are floats."]}],[{"l":"os","p":["This module is optional to be compiled."]},{"i":"osgetcwd","l":"os.getcwd()","p":["Returns the current working directory."]},{"i":"oschdirpath-str","l":"os.chdir(path: str)","p":["Changes the current working directory to the given path."]},{"i":"oslistdirpath-str","l":"os.listdir(path: str)","p":["Returns a list of files and directories in the given path."]},{"i":"osremovepath-str","l":"os.remove(path: str)","p":["Removes the file at the given path."]},{"i":"osmkdirpath-str","l":"os.mkdir(path: str)","p":["Creates a directory at the given path."]},{"i":"osrmdirpath-str","l":"os.rmdir(path: str)","p":["Removes the directory at the given path."]},{"i":"ospathjoinpaths-str","l":"os.path.join(*paths: str)","p":["Joins the given paths together."]},{"i":"ospathexistspath-str","l":"os.path.exists(path: str)","p":["Check if the given path exists."]},{"i":"ospathbasenamepath-str","l":"os.path.basename(path: str)","p":["Returns the basename of the given path."]}],[{"l":"pickle"},{"i":"pickledumpsobj---bytes","l":"pickle.dumps(obj) - bytes","p":["Return the pickled representation of an object as a bytes object."]},{"i":"pickleloadsb-bytes","l":"pickle.loads(b: bytes)","p":["Return the unpickled object from a bytes object."]},{"i":"what-can-be-pickled-and-unpickled","l":"What can be pickled and unpickled?","p":["The following types can be pickled:","None, True, and False;","integers, floating-point numbers;","strings, bytes;","tuples, lists, sets, and dictionaries containing only picklable objects;","functions (built-in and user-defined) accessible from the top level of a module (using def, not lambda);","classes accessible from the top level of a module;","instances of such classes","The following magic methods are available:","__getnewargs__","__getstate__","__setstate__","__reduce__"]}],[{"l":"random"},{"i":"randomseeda","l":"random.seed(a)","p":["Set the random seed."]},{"i":"randomrandom","l":"random.random()","p":["Return a random float number in the range [0.0, 1.0)."]},{"i":"randomrandinta-b","l":"random.randint(a, b)","p":["Return a random integer in the range [a, b]."]},{"i":"randomuniforma-b","l":"random.uniform(a, b)","p":["Return a random float number in the range [a, b)."]},{"i":"randomchoiceseq","l":"random.choice(seq)","p":["Return a random element from a sequence."]},{"i":"randomshuffleseq","l":"random.shuffle(seq)","p":["Shuffle a sequence inplace."]}],[{"l":"re"},{"i":"rematchpattern-string","l":"re.match(pattern, string)","p":["Return a match object if the string matches the pattern, and None otherwise. (force match at the beginning of the string)"]},{"i":"researchpattern-string","l":"re.search(pattern, string)","p":["Return a match object if the string matches the pattern, and None otherwise."]},{"i":"resplitpattern-string","l":"re.split(pattern, string)","p":["Split the string by the occurrences of the pattern."]},{"i":"resubpattern-repl-string","l":"re.sub(pattern, repl, string)","p":["Return a copy of the string with all occurrences of the pattern replaced by the replacement string."]}],[{"l":"requests","p":["This module is experimental. To enable it, download httplib.h from here and place it in the same directory as pocketpy.h. Also set PK_MODULE_REQUESTS to 1 in config.h.","SSL is not supported."]},{"i":"requestsgeturl-headersnone---response","l":"requests.get(url, headers=None) - Response","p":["Send a GET request to url and return a Response object."]},{"i":"requestsposturl-datanone-headersnone---response","l":"requests.post(url, data=None, headers=None) - Response","p":["Send a POST request to url and return a Response object."]},{"i":"requestsputurl-datanone-headersnone---response","l":"requests.put(url, data=None, headers=None) - Response","p":["Send a PUT request to url and return a Response object."]},{"i":"requestsdeleteurl-headersnone---response","l":"requests.delete(url, headers=None) - Response","p":["Send a DELETE request to url and return a Response object."]}],[{"l":"sys"},{"i":"sysversion","l":"sys.version","p":["The version of pkpy."]},{"i":"sys_repl","l":"sys._repl()","p":["Get a REPL for this vm. Use its input method to feed strings to the REPL."]}],[{"l":"time"},{"i":"timetime","l":"time.time()","p":["Returns the current time in seconds since the epoch as a floating point number."]},{"i":"timesleepsecs","l":"time.sleep(secs)","p":["Suspend execution of the calling thread for the given number of seconds."]},{"i":"timelocaltime","l":"time.localtime()","p":["Returns the current struct time as a dict object."]}],[{"l":"timeit"},{"i":"timeittimeitf-number","l":"timeit.timeit(f, number)","p":["Returns the time taken to execute the given function f number times."]}],[{"l":"traceback"},{"i":"trackbackprint_exc---none","l":"trackback.print_exc() - None","p":["Print the last exception and its traceback."]},{"i":"trackbackformat_exc---str","l":"trackback.format_exc() - str","p":["Return the last exception and its traceback as a string."]}],[{"l":"Introduction","p":["We take a lot of inspiration from the lua api for these bindings. The key difference being most methods return a bool, true if it succeeded false if it did not.","Special thanks for @koltenpearson for bringing us the Lua Style API implementation."]},{"l":"Basic Functions"},{"i":"pkpy_vm-pkpy_vm_createbool-use_stdio-bool-enable_os","l":"pkpy_vm* pkpy_vm_create(bool use_stdio, bool enable_os)","p":["Creates a new Lua Style VM.","use_stdio: if true, the VM will use stdout and stderr","enable_os: if true, the VM will have access to the os library"]},{"i":"bool-pkpy_vm_runpkpy_vm-const-char-source","l":"bool pkpy_vm_run(pkpy_vm*, const char* source)","p":["Runs the given source code in the VM.","source: the source code to run"]},{"i":"void-pkpy_vm_destroypkpy_vm","l":"void pkpy_vm_destroy(pkpy_vm*)","p":["Destroys the VM."]}],[{"l":"Stack Manipulation","p":["Stack index is 0-based instead of 1-based."]},{"l":"Push and Pop"},{"i":"bool-pkpy_poppkpy_vm-int-n","l":"bool pkpy_pop(pkpy_vm*, int n)","p":["Pop n items from the stack."]},{"i":"bool-pkpy_push_functionpkpy_vm-pkpy_function-int-argc","l":"bool pkpy_push_function(pkpy_vm*, pkpy_function, int argc)","p":["Push a function onto the stack. The function is of typedef int (*pkpy_function)(pkpy_vm*); The provided function should return the number of return values it leaves on the stack"]},{"i":"bool-pkpy_push_intpkpy_vm-int","l":"bool pkpy_push_int(pkpy_vm*, int)","p":["Push an integer onto the stack."]},{"i":"bool-pkpy_push_floatpkpy_vm-double","l":"bool pkpy_push_float(pkpy_vm*, double)","p":["Push a float onto the stack."]},{"i":"bool-pkpy_push_boolpkpy_vm-bool","l":"bool pkpy_push_bool(pkpy_vm*, bool)","p":["Push a boolean onto the stack."]},{"i":"bool-pkpy_push_stringpkpy_vm-const-char","l":"bool pkpy_push_string(pkpy_vm*, const char*)","p":["Push a string onto the stack."]},{"i":"bool-pkpy_push_stringnpkpy_vm-const-char-int-length","l":"bool pkpy_push_stringn(pkpy_vm*, const char*, int length)","p":["Push a string onto the stack.","length: the length of the string"]},{"i":"bool-pkpy_push_voidppkpy_vm-void","l":"bool pkpy_push_voidp(pkpy_vm*, void*)","p":["Push a void pointer onto the stack."]},{"i":"bool-pkpy_push_nonepkpy_vm","l":"bool pkpy_push_none(pkpy_vm*)","p":["Push None onto the stack."]},{"l":"Size Queries"},{"i":"bool-pkpy_check_stackpkpy_vm-int-free","l":"bool pkpy_check_stack(pkpy_vm*, int free)","p":["Return true if at least free empty slots remain on the stack."]},{"i":"int-pkpy_stack_sizepkpy_vm","l":"int pkpy_stack_size(pkpy_vm*)","p":["Return the number of elements on the stack."]},{"l":"Conversion"},{"i":"bool-pkpy_to_intpkpy_vm-int-index-int-ret","l":"bool pkpy_to_int(pkpy_vm*, int index, int* ret)","p":["Convert the value at the given index to an integer."]},{"i":"bool-pkpy_to_floatpkpy_vm-int-index-double-ret","l":"bool pkpy_to_float(pkpy_vm*, int index, double* ret)","p":["Convert the value at the given index to a float."]},{"i":"bool-pkpy_to_boolpkpy_vm-int-index-bool-ret","l":"bool pkpy_to_bool(pkpy_vm*, int index, bool* ret)","p":["Convert the value at the given index to a boolean."]},{"i":"bool-pkpy_to_voidppkpy_vm-int-index-void-ret","l":"bool pkpy_to_voidp(pkpy_vm*, int index, void** ret)","p":["Convert the value at the given index to a void pointer."]},{"i":"bool-pkpy_to_stringpkpy_vm-int-index-char-ret","l":"bool pkpy_to_string(pkpy_vm*, int index, char** ret)","p":["Convert the value at the given index to a string (strong reference).","ret is null terminated.","You are responsible for freeing the string when you are done with it."]},{"i":"bool-pkpy_to_stringnpkpy_vm-int-index-const-char-ret-int-size","l":"bool pkpy_to_stringn(pkpy_vm*, int index, const char** ret, int* size)","p":["Convert the value at the given index to a string (weak reference).","ret is not null terminated.","size is the length of the string.","The string is only valid until the next API call."]}],[{"l":"Type Checking"},{"i":"bool-pkpy_is_intpkpy_vm-int-index","l":"bool pkpy_is_int(pkpy_vm*, int index)","p":["Return true if the value at the given index is an integer."]},{"i":"bool-pkpy_is_floatpkpy_vm-int-index","l":"bool pkpy_is_float(pkpy_vm*, int index)","p":["Return true if the value at the given index is a float."]},{"i":"bool-pkpy_is_boolpkpy_vm-int-index","l":"bool pkpy_is_bool(pkpy_vm*, int index)","p":["Return true if the value at the given index is a boolean."]},{"i":"bool-pkpy_is_stringpkpy_vm-int-index","l":"bool pkpy_is_string(pkpy_vm*, int index)","p":["Return true if the value at the given index is a string."]},{"i":"bool-pkpy_is_voidppkpy_vm-int-index","l":"bool pkpy_is_voidp(pkpy_vm*, int index)","p":["Return true if the value at the given index is a void pointer."]},{"i":"bool-pkpy_is_nonepkpy_vm-int-index","l":"bool pkpy_is_none(pkpy_vm*, int index)","p":["Return true if the value at the given index is None."]}],[{"l":"Callables"},{"i":"bool-pkpy_callpkpy_vm-int-argc","l":"bool pkpy_call(pkpy_vm*, int argc)","p":["First push callable you want to call, then push the arguments to send.","argc is the number of arguments that was pushed (not counting the callable)."]},{"i":"bool-pkpy_call_methodpkpy_vm-const-char-name-int-argc","l":"bool pkpy_call_method(pkpy_vm*, const char* name, int argc)","p":["First push the object the method belongs to (self), then push the the argments.","argc is the number of arguments that was pushed (not counting the callable or self)","name is the name of the method to call on the object"]}],[{"l":"Variables"},{"i":"bool-pkpy_check_globalpkpy_vm-const-char-name","l":"bool pkpy_check_global(pkpy_vm*, const char* name)","p":["Return true if the global variable exists."]},{"i":"bool-pkpy_set_globalpkpy_vm-const-char-name","l":"bool pkpy_set_global(pkpy_vm*, const char* name)","p":["Set the global variable to the value at the top of the stack."]},{"i":"bool-pkpy_get_globalpkpy_vm-const-char-name","l":"bool pkpy_get_global(pkpy_vm*, const char* name)","p":["Get the global variable and push it to the top of the stack."]},{"i":"bool-pkpy_getattrpkpy_vm-const-char-name","l":"bool pkpy_getattr(pkpy_vm*, const char* name)","p":["A wrapper of OP_LOAD_ATTR bytecode."]},{"i":"bool-pkpy_setattrpkpy_vm-const-char-name","l":"bool pkpy_setattr(pkpy_vm*, const char* name)","p":["A wrapper of OP_STORE_ATTR bytecode."]},{"i":"bool-pkpy_evalpkpy_vm-const-char-code","l":"bool pkpy_eval(pkpy_vm*, const char* code)","p":["Evaluate the code and push the result to the top of the stack."]}],[{"l":"Error Handling"},{"i":"bool-pkpy_clear_errorpkpy_vm-char-message","l":"bool pkpy_clear_error(pkpy_vm*, char** message)","p":["If a method returns false, call the pkpy_clear_error method to check the error and clear it","If pkpy_clear_error returns false, it means that no error was set, and it takes no action","If pkpy_clear_error returns true, it means there was an error and it was cleared. It will provide a string summary of the error in the message parameter (if it is not NULL) If null is passed in as message, and it will just print the message to stderr.","You are responsible for freeing message."]},{"i":"bool-pkpy_check_errorpkpy_vm","l":"bool pkpy_check_error(pkpy_vm*)","p":["Return true if the vm is currently in an error state."]},{"i":"bool-pkpy_errorpkpy_vm-const-char-name-const-char-message","l":"bool pkpy_error(pkpy_vm*, const char* name, const char* message)","p":["Set the error state of the vm. It is almost equivalent to raise in python."]}],[{"l":"VM"},{"i":"vm-pkpy_new_vm","l":"VM* pkpy_new_vm()","p":["Create a virtual machine."]},{"i":"void-pkpy_vm_add_modulevm-vm-const-char-name-const-char-source","l":"void pkpy_vm_add_module(VM* vm, const char* name, const char* source)","p":["Add a source module into a virtual machine."]},{"i":"void-pkpy_vm_execvm-vm-const-char-source","l":"void pkpy_vm_exec(VM* vm, const char* source)","p":["Run a given source on a virtual machine."]},{"i":"void-pkpy_vm_exec_2pkpyvm-vm-const-char-source-const-char-filename-int-mode-const-char-module","l":"void pkpy_vm_exec_2(pkpy::VM* vm, const char* source, const char* filename, int mode, const char* module)","p":["Advanced version of pkpy_vm_exec."]},{"i":"void-pkpy_freevoid-p","l":"void pkpy_free(void* p)","p":["Free a pointer via free."]},{"i":"void-pkpy_delete_vmvm-vm","l":"void pkpy_delete_vm(VM* vm)","p":["Delete a virtual machine."]},{"i":"void-pkpy_delete_replrepl-repl","l":"void pkpy_delete_repl(REPL* repl)","p":["Delete a REPL."]},{"i":"void-pkpy_vm_compilevm-vm-const-char-source-const-char-filename-int-mode-bool-ok-char-res","l":"void pkpy_vm_compile(VM* vm, const char* source, const char* filename, int mode, bool* ok, char** res)","p":["Compile a source into bytecode and serialize it into a string.","ok: whether the compilation is successful.","res: if ok is true, res is the bytecode string, otherwise it is the error message."]}],[{"l":"REPL"},{"i":"repl-pkpy_new_replvm-vm","l":"REPL* pkpy_new_repl(VM* vm)","p":["Create a REPL, using the given virtual machine as the backend."]},{"i":"bool-pkpy_repl_inputrepl-r-const-char-line","l":"bool pkpy_repl_input(REPL* r, const char* line)","p":["Input a source line to an interactive console. Return true if need more lines."]}],[{"l":"Welcome to PocketPyUnity","p":["PocketPyUnity is a C# plugin that allows you to do Python scripting in Unity. It provides a sandboxed Python environment, adding dynamic capabilities to your game, which can be used for dynamic game logic, modding, hot fixing, and more.","The virtual machine is written in pure C#, which means you can fully control the internal state of the Python interpreter.","PocketPyUnity is designed for game scripting, not for scientific computing. You cannot use it to run NumPy, OpenCV, or any other CPython extension modules."]},{"l":"Features","p":["The VM class provides a sandboxed Python environment and a set of APIs for interacting with it."]},{"l":"Construction","p":["VM()","Create a new Python virtual machine."]},{"l":"Code Execution","p":["CodeObject Compile(string source, string filename, CompileMode mode)","Compile Python source code into a CodeObject that can be executed later. The filename parameter is used for error reporting, you can set it to main.py if you don't need it. The mode parameter specifies the compile mode, see CompileMode for details.","object Exec(CodeObject co, PyModule mod = null)","Execute a CodeObject in the given module. The mod parameter specifies the module in which the code will be executed. If it is null, the code will be executed in the main module.","object Exec(string source, string filename, CompileMode mode = CompileMode.EXEC_MODE, PyModule mod = null)","Compile and execute Python source code in the given module. It is equivalent to Exec(Compile(source, filename, mode), mod).","object Call(object callable, object[] args, Dictionarystring, object kwargs)","Call a Python callable object with the given arguments and keyword arguments. It is equivalent to callable(*args, **kwargs) in Python.","object CallMethod(object obj, string name, params object[] args)","Call a method of a Python object with the given arguments. It is equivalent to obj.name(*args) in Python."]},{"l":"Attribute Access","p":["object GetAttr(object obj, string name, bool throwErr = true)","Get an attribute of a Python object. It is equivalent to obj.name in Python. If throwErr is true, it will throw an exception if the attribute does not exist. Otherwise, it will return null.","NoneType SetAttr(object obj, string name, object value)","Set an attribute of a Python object. It is equivalent to obj.name = value in Python.","bool HasAttr(object obj, string name)","Check if a Python object has the given attribute. It is equivalent to hasattr(obj, name) in Python."]},{"l":"Module Access","p":["Dictionarystring, PyModule modules","A dictionary that maps module names to PyModule objects. You can use it to access the modules that have been imported.","Dictionarystring, string lazyModules","A dictionary stores all unimported modules. You can add Python source into this dictionary. It will be initialized and moved to modules when it is first imported.","PyModule NewModule(string name)","Create a new module with the given name at runtime. The module will be added to modules automatically.","PyModule PyImport(string name)","Import a Python module. It is equivalent to import name in Python. It first checks if the module has been imported, if not, it will try to load the module from lazyModules."]},{"l":"Type Conversion","p":["bool PyBool(object obj)","bool PyEquals(object lhs, object rhs)","Check if two Python objects are equal. It is equivalent to lhs == rhs in Python. This is different from == or object.ReferenceEquals in C#. You should always use this method to compare Python objects.","Convert a Python object to a boolean value. It is equivalent to bool(obj) in Python.","Convert a Python object to a string representation. It is equivalent to repr(obj) in Python.","Convert a Python object to a string. It is equivalent to str(obj) in Python.","Convert an Iterable Python object to a list. It is equivalent to list(obj) in Python.","Get an iterator of a Python object. It is equivalent to iter(obj) in Python.","Get the hash value of a Python object. It is equivalent to hash(obj) in Python.","Get the next element of a Python iterator. It is equivalent to next(obj) in Python.","int PyHash(object obj)","Listobject PyList(object obj)","object PyIter(object obj)","object PyNext(object obj)","string PyRepr(object obj)","string PyStr(object obj)"]},{"l":"Callbacks","p":["System.Actionstring stdout = Debug.Log","A callback that will be called when the Python code invokes print function. By default, it will print the message to Unity console.","System.Actionstring stderr = Debug.LogError","A callback that will be called when the Python code emits an error message. By default, it will print the exception message to Unity console."]},{"l":"Debug Flag","p":["bool debug = false","A flag that controls whether to print debug messages to Unity console. You can set it to true to enable debug messages, or false to disable them."]},{"l":"Bindings","p":["1"]},{"l":"Examples","p":["1"]}],[{"l":"Coding Style Guide"},{"l":"Naming rules","p":["For class names, always use PascalCase","For function and methods, use snake_case","For special python objects, use the same name as in python.","For global constants, use k prefix with PascalCase","For macros, use SNAKE_CASE"]},{"l":"Access control","p":["Please use python style access control.","We do not recommend to use C++ keywords such as private or public to achieve access control. Also do not write any trivial setter/getter.","Use a single _ as prefix to indicate a function or variable is for internal use.","_ prefix is just a warning to remind you to use such members carefully.","It does not forbid users to access internal members."]},{"l":"Use compact style","p":["Try to make the code compact if it does not affect readability."]},{"l":"For shared_ptrT","p":["Use a _ suffix to indicate a type is a shared pointer."]}],[{"l":"Developer guide","p":["There are some scripts to help you develop this project."]},{"l":"Build scripts","p":["build.py is the main script to build the project."]},{"l":"Test scripts"},{"l":"Distribution scripts","p":["It will generate a single pocketpy.h and main.cpp in amalgamate/ directory."]}],[{"l":"Performance","p":["Currently, pkpy is completely faster than cpython 3.8. Here is a benchmark result of the current commit.","Benchmark files are located in benchmarks/.","See actions/runs."]}],[{"l":"License","p":["pkpy is licensed under the MIT License."]}]]